{"id":1298176047,"question_id":105,"lang":"cpp","lang_name":"C++","time":"1 week, 5 days","timestamp":1719179736,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1298176047/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    void build(){\n\n    }\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        TreeNode* Node = nullptr;\n        unordered_map<int,TreeNode*> treeMap;\n        for(int i = 0 ; i < preorder.size();++i){\n            treeMap[preorder[i]] = new TreeNode(preorder[i]);\n        }\n        for(auto node : treeMap){\n            int posInorder = find(inorder.begin(),inorder.end(),node.first) - inorder.begin();\n            int posPreorder = find(preorder.begin(),preorder.end(),node.first) - preorder.begin();\n            if(pos - 2 >= 0 ){\n                node.second->left = treeMap[inorder[pos-2]];\n            }else if(pos - 1 >= 0) {\n                node.second->left = treeMap[inorder[pos-1]];\n            }\n\n            if(pos + 2 < preorder.size()){\n                node.second->left = treeMap[inorder[pos+2]];\n            }else if(pos + 1 < preorder.size()){\n                node.second->left = treeMap[inorder[pos+1]];\n            }\n\n        }\n        \n    return treeMap[preorder[0]];\n    }\n};","compare_result":null,"title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal","has_notes":false,"flag_type":1}