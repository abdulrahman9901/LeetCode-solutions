{"id":1298189636,"question_id":105,"lang":"cpp","lang_name":"C++","time":"1 week, 5 days","timestamp":1719181652,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1298189636/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    void build(){\n\n    }\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        TreeNode* Node = nullptr;\n        map<int,TreeNode*> treeMap;\n        int posIn , posPre , shortage = 0;\n        for(int i = 0 ; i < preorder.size();++i){\n            treeMap[preorder[i]] = new TreeNode(preorder[i]);\n        }\n        for(int i = 0 ; i < preorder.size();++i){\n            posIn = find(inorder.begin(),inorder.end(),preorder[i]) - inorder.begin();\n            posPre = find(preorder.begin(),preorder.end(),preorder[i]) - preorder.begin();\n            Node = treeMap[preorder[i]];\n            int leftChildIndx = 2 * (posPre + 1) - shortage - 1; \n            int rightChildIndx = 2 * (posPre + 1) - shortage ;\n            if(leftChildIndx < preorder.size() &&\n             ( posIn - 1 >=0 && preorder[leftChildIndx] == inorder[posIn - 1] || \n               posIn - 2 >=0 && preorder[leftChildIndx] == inorder[posIn - 2]) )\n                {\n                    Node->left = treeMap[preorder[leftChildIndx]];\n            }else {\n                shortage++;\n            }\n\n            if(rightChildIndx < preorder.size() &&\n             ( posIn + 1 < inorder.size() && preorder[rightChildIndx] == inorder[posIn + 1] || \n               posIn + 2 < inorder.size() && preorder[rightChildIndx] == inorder[posIn + 2]) )\n                {\n                    Node->right = treeMap[preorder[rightChildIndx]];\n            }else {\n                shortage++;\n            }\n        }\n    return treeMap[preorder[0]];\n    }\n};","compare_result":"11101100000000010000101000000000000000001000000000000000000000010100000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000010100001","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal","has_notes":false,"flag_type":1}