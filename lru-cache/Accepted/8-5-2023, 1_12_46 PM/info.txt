{"id":1012767865,"question_id":146,"lang":"cpp","lang_name":"C++","time":"11Â months","timestamp":1691230366,"status":10,"status_display":"Accepted","runtime":"403 ms","url":"/submissions/detail/1012767865/","is_pending":"Not Pending","title":"LRU Cache","memory":"165 MB","code":"#include <unordered_map>\n\nclass LRUCache {\n    struct Node {\n        int key;\n        int value;\n        Node* prev;\n        Node* next;\n        Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}\n    };\n\n    int capacity;\n    std::unordered_map<int, Node*> cacheMap;\n    Node* head;\n    Node* tail;\n\npublic:\n    LRUCache(int cap) : capacity(cap), head(nullptr), tail(nullptr) {}\n\n    int get(int key) {\n        if (cacheMap.find(key) != cacheMap.end()) {\n            moveToHead(cacheMap[key]); // Update LRU order\n            return cacheMap[key]->value;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cacheMap.find(key) != cacheMap.end()) {\n            cacheMap[key]->value = value; // Update value\n            moveToHead(cacheMap[key]); // Update LRU order\n        } else {\n            if (cacheMap.size() == capacity) {\n                evictLRU();\n            }\n            Node* newNode = new Node(key, value);\n            cacheMap[key] = newNode;\n            addToHead(newNode);\n        }\n    }\n\nprivate:\n    void moveToHead(Node* node) {\n        if (node == head) {\n            return;\n        }\n\n        // Update the previous node's next pointer\n        if (node->prev) {\n            node->prev->next = node->next;\n        }\n\n        // Update the next node's prev pointer\n        if (node->next) {\n            node->next->prev = node->prev;\n        } else {\n            tail = node->prev;\n        }\n\n        // Update node's pointers\n        node->prev = nullptr;\n        node->next = head;\n\n        // Update head's prev pointer\n        if (head) {\n            head->prev = node;\n        }\n\n        head = node;\n    }\n\n    void addToHead(Node* node) {\n        node->prev = nullptr;\n        node->next = head;\n        if (head) {\n            head->prev = node;\n        }\n        head = node;\n\n        if (!tail) {\n            tail = node;\n        }\n    }\n\n    void evictLRU() {\n        if (tail) {\n            cacheMap.erase(tail->key);\n            if (tail->prev) {\n                tail->prev->next = nullptr;\n            } else {\n                head = nullptr;\n            }\n            Node* temp = tail;\n            tail = tail->prev;\n            delete temp;\n        }\n    }\n};\n","compare_result":"1111111111111111111111","title_slug":"lru-cache","has_notes":false,"flag_type":1}